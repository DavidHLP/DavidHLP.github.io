---
title: Linux 高CPUプロセス Troubleshooting 一時停止ガイド
timestamp: 2026-02-25 00:00:00+08:00
tags: [Linux, 運用, トラブルシューティング]
description: Linuxシステムで高CPUプロセスを迅速に特定し、kill -STOPを使用してプロセスを一時停止してシステムのフリーズを防ぐ方法、および異常原因を詳しく調査する完全な手順を説明します。
toc: true
---

Linuxシステムでは、高CPUプロセスのトラブルシューティング、原因分析、およびシステムのフリーズを防ぐための一時停止は、標準的な運用操作手順です。詳細なステップバイステップガイドは以下の通りです：

---

## ステップ1：高CPUプロセスを迅速に特定する

システムの負荷が高すぎる場合、まずどのプロセス（PID）がCPUを消費しているかを特定する必要があります。

### 1. `top` コマンドの使用（リアルタイム表示）

`top` を入力すると：

- デフォルトでCPU使用率順にソートされます。されていない場合は、キーボードの **`P`** （大文字）を押して強制的にCPU順にソートします。
- `%CPU` 列を観察して、最もリソースを消費しているプロセスのPIDとコマンド名（`COMMAND`）を見つけます。
- **PID** をメモします（例：12345）。

### 2. `htop` コマンドの使用（より直感的なインターフェース、インストール済みの場合）

`htop` を入力すると、より使いやすいインターフェースになり、ヘッダーのクリックソートやより明確な色分けがサポートされます。

### 3. `ps` コマンドの使用（ワンタイムスナップショット）

`top` が凍って入力できない場合は、以下のコマンドで上位10の高CPUプロセスを直接リストできます：

```bash
ps -eo pid,ppid,cmd,%cpu,%mem --sort=-%cpu | head -n 11
```

---

## ステップ2：緊急の一時停止プロセス（フリーズ防止）

深い調査の前に、CPUが100%に急上昇してシステムの応答が非常に遅くなっている場合、**最優先タスクはプロセスを一時停止**してCPUリソースを解放することです。直接killすると、现场情報を失ったりビジネスロジックエラーが発生したりする可能性があります。

### 方法A：`kill -STOP` の使用（推奨）

これは最も安全な方法です。プロセスを「停止」状態（State が `T`）にし、CPUを消費しませんが、メモリとコンテキストを保持し、いつでも再開できます。

```bash
# 構文：kill -STOP <PID>
# 例：PID 12345 のプロセスを一時停止
sudo kill -STOP 12345
```

- **効果**：プロセスが直ちに停止し、CPU使用率はゼロになります。
- **再開方法**：調査後、`sudo kill -CONT 12345` を使用して再開します。

### 方法B：`killall -STOP` の使用（名前で一時停止）

プロセス名は知っているが具体的なPIDを知らない場合、または同じ名前の複数のプロセスがある場合：

```bash
# 例：java という名前のすべてのプロセスを一時停止
sudo killall -STOP java
```

### 方法C：優先度の調整（降格、完全停止ではない）

完全に一時停止までは必要なく、単にCPUの使用率を下げたい場合は、優先度を最も低く設定できます（Nice値の最大値は19）：

```bash
# 構文：renice -n 19 -p <PID>
sudo renice -n 19 -p 12345
```

> [!WARNING]
> プロセスが無限ループ計算の場合、最も高いNice値でも、シングルコアCPUがまだ占領されている可能性があります。この場合は `STOP` を使用する必要があります。

---

## ステップ3：異常原因の深い調査

プロセスが一時停止すると、システムが正常に戻り、原因を冷静に分析できます。

### 1. プロセス詳細情報の確認

```bash
 # プロセスの起動コマンド、パス、ユーザーを表示
ps -ef | grep <PID>
# より詳細なステータスを表示
cat /proc/<PID>/status
```

### 2. プロセスが開いているファイルとネットワーク接続の確認

高CPUの原因は、大量のファイルI/O待受やネットワークパケット処理の場合があります。

```bash
# 開いているファイルを表示
ls -l /proc/<PID>/fd
# ネットワーク接続を表示（netstat または ss が必要）
ss -antp | grep <PID>
# または lsof を使用
lsof -p <PID>
```

### 3. スタック情報の取得（コアステップ）

コードがどこで止まっているを知るには、スレッドスタックを表示する必要があります。

#### Javaプロセスの場合

`jstack` ツール（JDKに付属）を使用：

```bash
jstack -l <PID> > /tmp/java_stack.log
```

ログ内の `RUNNABLE` 状態のスレッドを分析し、コードがどの行で停止しているかを確認します。

#### C/C++/Go/Pythonなどのネイティブプロセスの場合

`gdb` （GNU Debugger）を使用してプロセスにアタッチします（**注意：リアルタイムのスタックを表示するには、プロセスが実行状態にある必要があります。STOP状態の場合、gdbをアタッチしたらcontinueして中断するか、コアダンプを直接分析してください**）。

*簡単な方法：`pstack` の使用（インストールされている場合）*

```bash
pstack <PID>
```

*一般的な方法：`gdb` の使用*

```bash
# 1. 最初にプロセスを再開する（ライブスタックをキャプチャするため、通常は少し実行させてから中断するか、直接アタッチ）
sudo kill -CONT <PID>

# 2. gdb をアタッチ
sudo gdb -p <PID>

# 3. gdb インタラクティブインターフェースで、直ちに割込み信号を送信（Ctrl+C）
# 次に bt (backtrace) を入力してスタックを表示
(gdb) bt full
# すべてのスレッドを表示
(gdb) thread apply all bt
# gdb を終了（プロセスを殺さないで）
(gdb) detach
(gdb) quit
```

### 4. `perf` を使用したパフォーマンス分析（上級者向け）

どの特定の関数がCPUを消費しているかを知る必要がある場合：

```bash
# 10秒間のデータを記録
sudo perf record -F 99 -p <PID> -g -- sleep 10
# レポートを生成
sudo perf report
```

これによりフレームグラフデータが表示され、どの関数コールスタックが最も時間を消費しているかが直感的にわかります。

### 5. システムログの確認

関連するエラーがあるかどうかを確認：

```bash
dmesg -T | tail -n 50
grep <PID> /var/log/syslog  # または /var/log/messages
```

---

## ステップ4：フォローアップ処理

調査結果に基づいて操作を決定します：

### 1. 一時的な変動/既知の問題の場合

プロセスを再開して実行を継続：

```bash
sudo kill -CONT <PID>
```

### 2. 無限ループ/バグ/悪意のあるプログラムの場合

プロセスを直接終了：

```bash
# グレースフル終了（プログラムにリソースをクリーンアップさせる）
sudo kill -TERM <PID>

# 強制終了（TERM が効かない場合）
sudo kill -KILL <PID>
```

### 3. 長期的な予防

- systemd サービスの `CPUQuota` を構成して、そのサービスが使用できるCPUの最大百分比を制限します。
- コードロジックを最適化します。
- 監視アラート（Prometheus + Alertmanagerなど）を展開して、CPU急上昇の初期段階で自動的に介入します。

---

## まとめフローチャート

1. **ラグを検出** -> `top` でPIDを見つける。
2. **緊急止血** -> `kill -STOP <PID>` （重要なステップ、フリーズ防止）。
3. **冷静に分析** -> `jstack` / `gdb` / `perf` / `lsof` で原因を特定。
4. **意思決定と実行** -> `kill -CONT` （再開）または `kill -KILL` （終了）。
