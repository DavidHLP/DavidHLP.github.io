---
title: 博研Java后端开发实习生二面面经
timestamp: 2026-02-23 00:00:00+08:00
series: 面试经验
tags: [Java, 面试, 后端, 实习]
description: 博研Java后端开发实习生二面面经，考察重点包括消息队列、容器化、WebSocket、设计模式、系统性能优化、线上排障等
toc: true
---

**面试岗:** Java后端开发实习生
**面试时长:** 约45分钟
**考察重点:** 复杂项目架构设计（消息队列、容器化、WebSocket）、设计模式的业务落地、系统性能优化、线上排障及工程化思维。

本次二面相对一面来说，面试官（资深工程师）更加看重**技术的选型思考**以及**生产环境的工程化思维**。整场面试下来收获非常大，特别是最后关于线上排障的拷问，让我深刻意识到了学生思维和企业级开发的差距。以下是详细的面经复盘。

---

## 一、 破冰与项目深挖（在线判题OJ系统）

> **Q1：先简单做个自我介绍吧。**
> **我：** 面试官好，我是软件/大数据相关专业的本科生，主攻Java后端方向。熟悉 Spring Boot/Cloud、Redis、MySQL、MyBatis 等，前端 Vue/React 也略懂。主要的项目经历包括一个 Spring Cache 的缓存中间件二次开发、一个基于微服务架构的信息管理系统，以及目前正在做的核心项目——类似 LeetCode 的在线编程判题（OJ）系统。

> **Q2：做了这么多项目，你觉得哪一个印象最深刻、难度最高？**
> **我：** 印象最深的是目前在做的 OJ 在线判题系统。它的业务逻辑比较复杂，为了实现代码的沙箱运行，我引入了 **Docker** 进行环境隔离；面对高并发的代码提交场景，使用了 **Kafka** 做消息队列进行削峰填补；并且前端和后端之间采用了 **WebSocket** 进行通信，以实时推送代码运行结果。

> **Q3：你提到了 WebSocket，它和普通的 HTTP 有什么区别？既然 WebSocket 这么好用（双向通信），为什么目前主流网站还是用 HTTP？**
> **我：**
> - **区别：** HTTP 是单向的、基于请求-响应模式的；而 WebSocket 握手成功后会建立持久的连接，服务端和客户端可以互相主动推送数据。
> - **为什么不用 WebSocket 替代 HTTP：** 因为维持长连接需要占用服务器的连接池资源和内存。服务器的并发连接数是有限的，如果所有请求都用 WebSocket，资源会被极速耗尽。HTTP 的"用完即走（无状态、短连接或 Keep-Alive）"模式在应对绝大多数只需要单次数据交互的场景下，资源利用率更高，更具动态性和高效性。

> **Q4：你的代码沙箱是用 Docker 跑的，具体流程是怎样的？如何防止用户提交恶意代码导致服务器宕机？**
> **我：** 我没有直接在宿主机跑代码，而是预先构建了包含各种目标语言（如 Java、Python、C++）环境的 Docker 镜像，并启动了对应的容器。
> 当用户提交代码时，后端会获取代码和数据库中的测试用例，通过 Java 调用 Docker API，将文件挂载/传入指定的容器目录下，随后调用预设的脚本执行并捕获输出。因为是在 Docker 容器内运行，且对容器的 CPU/内存等资源做了限制，做到了物理隔离，从而保护了宿主机的安全。

> **Q5：如果在运行过程中 Docker 容器挂了怎么办？你有什么保活机制？**
> **我：**
> - **当前实现：** 目前是在 `docker-compose.yml` 中设置了 `restart: always`，交由 Docker 引擎自己去做保活。
> - **面试官追问：自己设计的话怎么做？** 我提出可以在 Java 后端写一个定时任务，通过 Docker API 尝试获取容器的元数据。如果获取失败，采用**指数退避算法（阶梯式重试）**：第一次失败等待一段时间重试，第二次失败等待时间翻倍……如果连续三次失败，则判定容器死亡，触发重新 `run` 一个新容器的逻辑。如果是容器被死锁占用，可以引入分布式锁机制进行状态标记。

> **Q6：既然用到了 Docker，了解过 K8s (Kubernetes) 吗？它和 Docker 有什么区别？**
> **我：** Docker 是单机层面的容器引擎，适合个人开发者或轻量级部署。而 K8s 是企业级的分布式容器编排系统，它管理的是多个宿主机（节点）组成的集群。如果单台服务器跑大量 Docker 容器会导致资源竞争和性能下降，K8s 则可以将容器合理调度到集群内资源充足的节点上，保证服务的高可用和稳定性。

> **Q7：你刚才提到用 Kafka 做削峰，具体是怎样的场景？**
> **我：** 比如系统举办了一场编程竞赛，短时间内会有大量并发提交代码的请求。但 Docker 启动脚本和执行代码是一个相对耗时的操作，如果用同步处理，服务器线程很快会被打满。
> 所以我将判题请求作为消息丢入 Kafka（生产者），然后让判题服务（消费者）按照自身处理能力，异步地从队列中拉取任务去执行。执行完毕后，再通过 WebSocket 将结果异步推送给前端。

---

## 二、 架构设计与设计模式（缓存中间件项目）

> **Q8：在你的项目里，有用过哪些设计模式？具体解决什么问题？**
> **我：** 在自己写的 Redis 缓存保护中间件中，我使用了**责任链模式**（结合了策略模式）。
> 因为缓存的查询流程很长：`校验布隆过滤器 -> 查本地缓存 -> 查 Redis -> 加防击穿锁 -> 回源数据库`。我将每一个步骤抽象为一个节点（Handler），通过统一的 Context 上下文传递数据。
>
> - **面试官追问：为什么要用责任链？是否有过度设计之嫌？**
> - **我的回答：** 主要是为了**高扩展性**和**可观测性**。通过责任链，我可以随时在链条中间插入监控节点（比如统计回源率、锁竞争次数），也可以在最后"回源DB"的节点轻松替换不同的实现（比如从 MySQL 换成 MongoDB），而不需要去改动核心的控制逻辑代码。

---

## 三、 性能优化与基础知识

> **Q9：看你简历写了有性能优化经验，能分享一个你把耗时从秒级优化到毫秒级/小秒级的案例吗？**
> **我：** 在校园信息管理系统中，有一个百万级数据表的全量 Excel 导出功能。一开始由于使用原生的 JDBC 循环查库和普通的文件写入，导致导出非常慢（十几秒甚至几十秒），而且遇到用户重复点击会导致服务器 OOM 或卡顿。
> - **优化手段：** 引入了异步任务队列，将用户的导出请求缓存起来排队执行；同时将底层的导出组件替换为类似 EasyExcel 的流式写入组件，避免将大量数据一次性加载到内存。最终优化到了 5 秒左右。
> - **面试官总结：** 所以你的优化主要集中在应用层面的内存处理和异步化，SQL 层面其实还是全量查对吧？（我：是的）

> **Q10：你们系统认证用的 JWT，它和以前老的 Session 机制有什么区别？**
> **我：**
> - **Session：** 状态保存在服务端内存中，存在扩展性问题，分布式环境下需要做 Session 共享。
> - **JWT：** 无状态机制。服务端校验账号密码后签发 Token，前端保存并在后续请求头中携带。后端只需通过秘钥解密校验即可。
> 为了实现 JWT 的可控性（如主动踢人、续期），我在服务端结合了 Redis，把签发后的 Token 存入 Redis 并设置过期时间。每次经过拦截器校验成功后，顺便刷新 Redis 中的存活时间。

> **Q11：计算机网络的 OSI 七层模型还记得吗？**
> **我：** （太久没背有点忘了，实话实说）物理层、数据链路层、网络层、传输层、应用层... 中间漏了会话层和表示层。

---

## 四、 灵魂拷问：线上排障（高潮部分）

> **Q12：Linux 下如果某台机器负载极高，怎么排查是哪个进程导致的？**
> **我：** 使用 `top` 命令，可以直观看到各个进程的 CPU 和内存占用。

> **Q13：拿到进程号之后，如何进一步定位问题？**（重点！）
> **我：** （当时脑子一抽，顺口说出了平时自己玩服务器的习惯）**"拿到进程号之后，我一般就直接 `kill -9` 把它杀掉了……"**
>
> **面试官（哭笑不得）：** 这么粗暴呀？这要是遇到线上的真实业务，直接这么干可是要背生产故障的呀！

> [!NOTE]
> 正确的思路应该是用 `top -Hp <pid>` 查看具体是哪个线程吃 CPU，然后用 `jstack` 导出线程快照，将线程号转为 16 进制去快照文件里对比，定位到具体导致死循环或 Full GC 的业务代码行数，而不是直接干掉进程！

---

## 五、 反问环节与面试官评价

> **我：** 今天面下来，您对我有什么评价和建议吗？想明确一下自己后续的提升方向。
>
> **面试官 Feedback：**
> 1. **优点：** 你的项目经验非常丰富，代码量应该不少。而且对于自己做的项目链路（如沙箱、MQ的使用、设计模式）比较清晰，技术广度不错。
> 2. **不足（致命伤）：** 明显**缺乏真实企业级实习经验和工程化思维**。最典型的就是刚才那个排查问题的回答（直接 `kill -9`）。在个人开发或者学校项目中这么干没问题，但在企业生产环境中，线上止血和排障是一套极其严谨的流程。
> 3. **结论：** 目前具备很好的底子，但要成为真正的即战力还需要培养。建议多去了解一下**线上问题排查实战**、**生产环境运维规范**以及一些工程化的知识。

---

## 总结体会

这场面试让我如梦初醒！虽然我堆了很多高大上的组件（Docker、Kafka、WebSocket、设计模式），在"造轮子"上花了很多功夫，但依然停留在"能跑就行"的学生思维阶段。

**特别是对于排障的回答，暴露了我缺乏对线上敬畏之心的短板。** 后续的复习中，我需要重点补齐 JVM 调优、线上 OOM排查、CPU 飙高排障分析（`jstack`, `jmap`, `arthas` 工具的使用）等实战经验。

希望能给还在校招或找实习的同学提个醒：**组件会用是一方面，懂得如何在生产环境中排障、容灾、保证可用性，才是大厂面试官真正看重的"高级素养"！**
