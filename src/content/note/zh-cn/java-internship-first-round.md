---
title: Java后端开发实习生一面面经
timestamp: 2026-02-23 00:00:00+08:00
series: 面试经验
tags: [Java, 面试, 后端, 实习]
description: Java后端开发实习生一面面经，考察重点包括Redis缓存、Docker容器化、Java基础集合类等
toc: true
---

**面试岗:** Java后端开发实习生
**面试形式:** 语音面试
**面试时长:** 约30分钟
**考察重点:** 项目深度（Redis缓存、Docker容器化）、问题排查思路、Java基础集合类

整体感觉面试官比较注重项目的实际落地细节，特别是缓存优化和Docker的使用。以下是面试的详细复盘记录。

---

## 一、 自我介绍与项目深挖

> **Q1：看你准备好了，先简单做一下自我介绍吧。**
> **我：** 面试官好，我是大四软件相关专业的学生，主攻Java后端方向。比较熟悉常用的中间件和底层数据库。最近主要做了一个基于 Spring Cache 二次开发的工具库，重点做了 Redis 相关的业务优化。

> **Q2：展开讲讲你这个 Spring Cache 的二开工具，是怎么解决缓存三大问题的？**
> **我：** 它是通过整条链路来预防穿透、击穿和雪崩的：
> - **缓存穿透：** 采用了**双层布隆过滤器**（JVM层的 BitSet + Redis Hash）。请求过来先查 JVM 层的布隆过滤器，没有的话再去 Redis 查。如果数据库查出来是空值，也会进行空值兜底缓存，防止下次继续打到数据库。
> - **缓存击穿：** 引入了 JVM 锁机制。当大量并发请求同一个 key 时，先在 JVM 层加锁，只放行一个请求去获取 Redis 锁并查询数据库。同时在 JVM 层做一层本地哈希缓存，后续请求直接从本地获取，减轻网络 IO。
> - **缓存雪崩：** 做了 **TTL 随机化扰动**（在原过期时间基础上做 ±30% 的随机浮动），防止大量 Key 同一时间失效。并且加入了**预刷新机制**，在请求时异步刷新过期时间。

> **Q3：看你的毕设项目是一个仿 LeetCode 的在线编程网站，核心的"代码沙箱（运行测试用例）"是怎么实现的？**
> **我：** 由于前端还在迭代，目前临时后端用 NestJS 写的，后续会转 Spring Cloud。代码沙箱的实现流程如下：
> 1. 用户在前端页面点击运行，如果是本地小测试，会转成 JS 在浏览器跑几个示例。
> 2. 如果是提交判题，前端会将代码传给后端，后端打包成可运行文件。
> 3. 后端通过调用 **Docker API**，将代码文件传入预先在 Linux (WSL2) 环境下部署好的各种语言（Java/Python/C++ 等）的 Docker 容器中。
> 4. 容器根据预设的脚本运行代码，通过标准输出（Output）返回 JSON 格式的执行结果。
> 5. 后端解析 JSON，与数据库中的预期结果（测试用例）进行比对并计分。

> **Q4：你这个 Docker 容器是怎么部署和运行的？进入容器的命令是什么？**
> **我：** 不同语言的容器是相互独立的。我会自定义 `Dockerfile` 并使用 `docker build` 构建镜像。运行的话，因为涉及多个服务，我会编写 `docker-compose.yml` 文件，使用 `docker-compose up -d` 进行一键编排和后台运行。
> 进入容器的命令是：`docker exec -it <容器名称或ID> /bin/bash`。

> **Q5：看你还有一个校园内网（信息员反馈）项目，里面用到了 ECharts 和 MySQL 多维度统计，具体是怎么做的？**
> **我：** 主要是为了给校领导提供可视化看板。比如统计"每个学院的反馈数量"，后端会使用 MySQL 进行 `GROUP BY` 聚合查询，X轴（Key）是学院名称，Y轴（Value）是反馈数量，最终后端组装成一个 `Map` 结构返回给前端，前端拿到数据后渲染成 ECharts 的柱状图或折线图。

---

## 二、 开发工具与问题排查

> **Q6：Spring Boot 项目离不开 Maven，你平时常用的 Maven 命令有哪些？**
> **我：** 最常用的是 `mvn clean`（清理编译文件），`mvn install`（打包并安装到本地仓库），还有 `mvn deploy`（部署到远程仓库）等。

> **Q7：情景题：前端点击一个按钮报错了/没反应，你作为后端怎么去排查和定位问题？**
> **我：**
> 1. **确认端点：** 首先打开浏览器的 `F12` 开发者工具，查看 Network（网络）面板。
> 2. **分析状态码：** 如果是 `404` 可能是接口地址写错；如果是 `401/403` 是权限问题；如果是 `500` 等状态码，明确是后端报错。如果是前端直接报语法错误，那就是前端问题。
> 3. **后端排查：** 明确是后端报错后，去服务器或控制台查看后端输出的 Error 日志，定位具体的异常堆栈。
> 4. **Debug 调试：** 如果控制台没有明显报错日志，但逻辑走不通，我会在 IDEA 对应的 Controller 接口处打上断点（Debug），重新发起请求，单步执行检查入参和中间变量，从而定位具体出错的代码行。

---

## 三、 Java 基础与集合框架

> **Q8：手撕/逻辑题：怎么将一个字符串反转？（比如 12345 变成 54321）**
> **我：**
> - **思路1（双指针交换）：** 创建首尾两个指针，分别向中间靠拢并交换元素，直到双指针相遇。
> - **思路2（倒序遍历拼接）：** 如果不考虑空间开销，可以直接把字符串转为 `char` 数组，然后用 `for` 循环从后往前遍历（`for (int i = s.length() - 1; i >= 0; i--)`），将字符塞入一个新的数组或 `StringBuilder` 中，最后转回 String。面试中口述了第二种实现。

> **Q9：说说 ArrayList 和 LinkedList 的区别？**
> **我：**
> - **底层结构：** `ArrayList` 底层是动态数组，`LinkedList` 底层是双向链表。
> - **查询性能：** `ArrayList` 由于内存连续且支持索引查，查询非常快（O(1)）；`LinkedList` 需要顺着指针遍历，查询慢（O(n)）。
> - **增删性能：** `ArrayList` 增删可能会涉及数组扩容和大量元素的复制移动，性能较差；`LinkedList` 只需改变前后节点的指针指向，增删效率很高，特别适合头尾操作。

> **Q10：怎么遍历 ArrayList？**
> **我：** 常见的有三种方式：
> 1. 普通的 `for` 循环，通过 `array.size()` 控制边界，利用 `array.get(i)` 获取。
> 2. 增强型 `for-each` 循环（底层其实还是迭代器）。
> 3. 使用 `Iterator` 迭代器遍历。

> **Q11：如果有一个数组里有重复数据，怎么去重？**
> **我：** 可以直接将数组元素放入 `HashSet` 中，利用 Set 的特性自动去重。

> **Q12：如果是自定义的对象放入 HashSet，怎么保证去重逻辑正确？**
> **我：** 需要在自定义的实体类中**重写 `equals()` 方法**。
>
> [!TIP]
> 除了 equals()，还必须重写 `hashCode()` 方法，因为 HashSet 底层依赖散列值来定位槽位，如果散列值不同，即使 equals 返回 true 也会被存入不同的位置。

---

## 四、 微服务框架

> **Q13：了解过 Dubbo 吗？和 Spring Cloud 的微服务注册消费有什么区别？**
> **我：** 只是了解过 Dubbo 是一个高性能的 RPC 框架，和 Spring Cloud 有点类似，都用于微服务的服务注册与消费。但平时开发主要用的还是 Spring Cloud 系列（Spring Boot + Spring Cloud），对 Dubbo 的具体使用细节不太清楚。

---

## 五、 面试反问

> **我：** 您对我今天的面试表现有什么建议吗？
> **面试官：** 没有建议，整体挺好的。

---

## 面试总结

本次面试难度适中，属于比较标准的一面。重点考察了：

1. **项目经历的真实度**：面试官对代码沙箱如何通过 Docker 运行以及对应的底层交互很感兴趣，这要求对项目的核心链路有清晰的认知。
2. **日常开发的基本功**：包括接口报错的排查思路，这种问题没有标准答案，考察的是日常 Coding 的经验积累。
3. **Java 基础的扎实度**：集合类的底层原理、对象去重的规范（重写 equals 和 hashCode）属于必考题，需要做到脱口而出。

总体聊得比较愉快，等待后续通知！希望能给大家带来帮助！
